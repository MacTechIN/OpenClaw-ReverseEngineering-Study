# OpenClaw(Moltbot) 해부학: 초보자를 위한 마이크로 가이드
> **작성자**: Sam LEE (여러분의 개발 코치)
### 이 책의 철학
> **"이해되지 않는 기술은 기술이 아니다."**

모든 코드는 우리네 인생(학교, 직장, 도로) 가장 가까운 주제에 빗대어 설명합니다. 기술적 개념이 낯설게 느껴질 때마다, 이 책은 여러분의 일상에서 친숙한 **은유(Metaphor)** 법을 사용하여 설명할 예정입니다.

### 4단계 분석법
이 책의 모든 설명은 다음 4단계(4-Step Analysis)를 따릅니다:

1.  **은유(Metaphor)**: 우리 주변의 익숙한 상황(학교, 회사, 신호체계 등)으로 개념을 잡습니다.
2.  **개념(Concept)**: 실제 기술 용어를 쉽게 정의합니다.
3.  **코드(Code)**: 모든 예제 코드는 주석을 달아 이해가 쉽도록 합니다.
4.  **배경(Context)**: 왜 이 기술을 선택했는지, 업계의 뒷이야기를 들려드립니다.

### 독자 대상
이 책은 코딩의 '코'자만 알아도 이해하고 싶어 하는 **열정적인 초심자**를 위한 것입니다. 전문 개발자가 아니더라도, 전공자가 아니더라도, 기술의 원리를 깊이 있게 이해하고 싶은 분이라면 누구나 환영합니다.

### 저자의 편지: 위기의 신입 개발자들에게 (Why Reverse Engineering?)

최근 IT 산업계에서는 신입 개발자 채용을 기피하는 경향이 뚜렷해지고 있습니다. 인공지능의 등장으로 개발자의 역할이 단순 코딩에서 '기획·설계' 중심의 기획개발로 전환되는 가운데, 기업들은 기획력과 문제 해결 능력이 검증된 경력자를 선호하게 된 것입니다. 이러한 현상은 업계의 당연한 수요 변화로 자리 잡았으며, IT 업계 전반으로 빠르게 확산되고 있는 실정입니다.

이에 필자는 스스로에게 묻게 되었습니다. **신입 사원의 경험 부재라는 문턱을 어떻게 하면 극복하고, 단기간에 경력자 수준의 실전 역량을 갖출 수 있을까?** 실제로 수많은 신입 지원자들의 면접과 코딩 테스트를 진행하면서, 이들의 어려움에 깊은 공감과 안타까움을 느꼈습니다. 과연 이들에게 희망적인 대안은 없는 것일까.

현실은 더욱 녹록지 않습니다. 기업들은 인턴 채용마저 축소하고 있어, 실무 경험을 쌓을 수 있는 기회조차 점차 좁아지고 있습니다. 바로 이러한 구조적 문제의식에서 본서를 기획하게 되었습니다.

필자는 이 책을 통해 초보 개발자, 신입 지망생, 그리고 비전공자이나 개발에 대한 열정을 품은 모든 이들에게 **경력자들이 수년에 걸쳐 체득한 실전 경험과 노하우를 압축하여 전달**하고자 합니다. 단순한 이론서가 아닌, 현장에서 마주하는 문제들을 직접 해결하며 몸으로 익히는 **'선배의 비밀노트'** 를 만들고 싶었습니다. 그리고 그 핵심 방법론으로 **리버스 엔지니어링(Reverse Engineering)** 이라는 역발상의 접근법을 제시하고 싶었습니다.

이미 만들어진 시스템을 분해하고 분석함으로써 설계자의 의도와 구조적 원리를 빠르게 파악하는 이 방법은, **신입 개발자가 단기간에 경력자 수준의 통찰력을 갖출 수 있는 가장 효과적인 경로**입니다. 이 책이 여러분의 실력 향상에 든든한 동반자가 되기를 바랍니다.

컴퓨터공학 전공자이든 비전공자이든, 개발자의 꿈을 품은 모든 분들께 진심 어린 응원의 마음을 전합니다. 어려운 환경일수록 스스로의 성장을 위해 끊임없이 노력하시길 바랍니다. 필자는 이 책을 통해 여러분의 도전을 끝까지 지원하겠습니다. 힘내십시오.

**AI 혁명은 결코 여러분의 직업을 빼앗아 가지 못합니다. 끊임없이 생기는 새로운 문제를 해결해 나가려는 열정은 인공지능에게는 없기 때문입니다.** 이 책을 밤새 탐독하며 인공지능을 여러분의 것으로 만드는 그날까지, 본서가 조금이나마 용기가 되길 기원합니다.

---

### [프로젝트 소개] OpenClaw(Moltbot) 건축 일지

이 문서는 **OpenClaw(Moltbot)** 이라는 2026년 시작과 함께 불어닥친 거대한 소프트웨어 파장을 **“밑바닥부터(from scratch)”** 다시 파헤치는 과정을 담은 건축 일지입니다. 단순히 인공지능이 코드를 생성하는 것만 “복사-붙여넣기” 하는 것이 아니라, **“왜 여기에 기둥을 세웠지?”, “이 배관은 어디로 연결되지?”** 를 집요하게 파헤치고 사고하고자 작성되었습니다.

인공지능 혁명의 물결 속에서 코딩은 전통적으로 인간만의 전유물이었던 시대를 지나, 이제는 인간과 기계가 협력하는 새로운 패러다임으로 진화하고 있습니다. 그러나 우리는 한 가지 근본적인 진리를 간과해서는 안 됩니다. **현존하는 모든 인공지능 시스템이 궁극적으로는 인간의 코드로 구현된 산물이라는 사실**을 말입니다.

코드의 정확한 의미와 작동 원리를 이해하지 못한 채, 인공지능이 생성하는 환각(hallucination)을 비판적으로 검토하지 않고 수용한다면, 이는 우리에게 잠재적 위험이자 반드시 극복해야 할 중대한 과제가 될 것입니다.

본서는 이러한 시대적 상황을 인식하고, 인공지능을 효과적인 학습 도구로 활용하여 코딩의 본질을 깊이 있게 이해하고 **리버스 엔지니어링(1)** 역량을 배양하고자 하는 독자들을 위한 실전 지침서로 제작하였습니다.



---

### ☕️ [Ice Breaking] 개발자의 일상, 그리고 '연결'의 고통

기술적인 이야기로 넘어가기 전에, 제(Sam LEE) 옛날이야기를 하나 해드릴까 합니다.

제가 개발자로 밥을 먹고 산 지 어느덧 20년이 다 되어갑니다.
많은 신입 개발자분들이 저에게 묻습니다.
*"팀장님, 어떤 알고리즘을 공부해야 개발을 잘하나요?"*
*"수학을 잘해야 코딩을 잘하나요?"*

그럴 때마다 저는 웃으며 대답합니다.
**"개발 생활의 8할은 '알고리즘'이 아니라 '눈치'와 '통역'이란다."**

실제로 현업에서 가장 골치 아픈 문제는 **'어려운 로직'** 을 짜는 게 아닙니다.
바로 **'말이 안 통하는 두 시스템을 연결하는 것'** 입니다.

*   기획팀은 "한국어"로 말하고, 개발팀은 "외계어(Code)"로 말합니다.
*   옆 부서 김 대리님이 만든 서버는 `JSON`을 달라고 하는데, 우리 팀 박 과장님이 만든 앱은 `XML`을 던집니다.
*   이 사이에서 **"아니, 그게 아니라요..."** 하며 중간 다리를 놓는 과정. 그것이 개발자가 겪는 매일매일의 스트레스이자, 가장 중요한 업무입니다.

우리가 지금 만들려고 하는 **OpenClaw(Moltbot)** 도 똑같습니다.
이 친구는 일종의 **"통역사(Translator)"** 입니다.

*   **WhatsApp**: "나는 내 방식대로 말할 거야!"
*   **Slack**: "나도 내 규칙이 있어!"
*   **AI(ChatGPT)**: "나는 텍스트만 주면 답할게."

이 제각각인 녀석들 사이에서 등 터지지 않고, 능수능란하게 말을 전달해 주는 **'센스 있는 중재자'**.
그것이 바로 **Gateway**입니다.

그러니 앞으로 나올 복잡한 그림들을 보고 겁먹지 마세요.
**"아, 이 코드는 지금 WhatsApp이랑 Slack 사이에서 통역하느라 땀 뻘뻘 흘리고 있구나."**
이렇게 생각하면, 차가운 코드 덩어리가 조금은 사람 냄새 나고 귀여워 보일 겁니다.

자, 그럼 이제 이 기특한 통역사의 가방 속에 어떤 도구들이 들어있는지 한번 열어볼까요?

---

## 0. 기술 스택 분석 (Technology Stack Analysis)

이 앱은 단순한 챗봇이 아니라, 다양한 메신저(WhatsApp, Slack 등)와 AI 모델을 연결하는 **Gateway Platform**입니다.

| 구분 | 기술 / 도구 | 버전 (권장) | 선정 이유 (Why?) |
| :--- | :--- | :--- | :--- |
| **Runtime** | **Node.js** | >=22.12.0 | 최신 LTS. 비동기 I/O 처리가 핵심인 게이트웨이 서버에 최적화됨. |
| **Language** | **TypeScript** | ^5.9.3 | 거대한 모노레포 프로젝트의 타입 안정성 보장. 인터페이스 기반 설계 필수. |
| **Package Manager** | **pnpm** | 10.23.0 | 모노레포 구조에서 디스크 공간 절약 및 빠른 설치 속도. |
| **Server Core** | **Hono** (+ WS) | 4.11.4 | Express보다 가볍고 빠르며, Edge Runtime 호환성이 좋음. HTTP/WebSocket 통합 용이. |
| **Channel Layer** | **Baileys** | 7.0.0-rc.9 | WhatsApp Web API를 리버스 엔지니어링한 라이브러리. 브라우저 없이 Node.js에서 WhatsApp 구동 가능. |
| **AI Agent** | **Pi Agent Core** | 0.49.3 | LLM(Large Language Model)과의 통신, 도구(Tool) 호출, 컨텍스트 관리를 담당하는 자체/외부 라이브러리. |
| **UI Framework** | **Lit** + **Vite** | 3.3.2 | React보다 가벼운 Web Components 표준 기반. 봇 제어 패널용으로 가볍고 빠름. |
| **Database/State** | **SQLite** | - | 로컬 임베딩 벡터 저장 및 경량 상태 관리에 적합. |

> [!TIP]
> **📚 [용어 미니 사전] 이게 도대체 무슨 말인가요?**
>
> 표에 나온 외계어들을 시원하게 풀어드립니다.
>
> 1.  **LTS (Long Term Support)**: "장기 지원 버전". 자동차로 치면 **'신형 쏘나타'** 가 아니라 **'택시 모델 쏘나타'** 입니다. 최신 기능은 적지만, 고장이 안 나고 부품을 5년 이상 책임지고 공급해 줍니다. 서버는 멋진 기능보다 **'안 죽는 것'** 이 중요해서 LTS를 씁니다.
> 2.  **모노레포 (Monorepo)**: "Mono(하나) + Repo(저장소)". **'한 지붕 대가족'** 입니다. 서버 코드, 앱 코드, 관리자 페이지 코드를 폴더 하나에 다 몰아넣고 관리하는 방식입니다. 반대말은 '멀티레포(각방 쓰기)'입니다.
> 3.  **리버스 엔지니어링 (Reverse Engineering)**: "역공학". 맛집 떡볶이 소스 비법을 알아내려고, 다 만들어진 떡볶이를 현미경으로 들여다보고 성분을 분석하는 행위입니다. 우리는 완성된 OpenClaw 코드를 뜯어보며 설계를 유추할 것입니다.
> 4.  **컨텍스트 (Context)**: "문맥/정황". AI는 금붕어입니다. 방금 한 말을 잊어버리죠. 그래서 "아까 네가 사과라고 했잖아"라고 **이전 대화 내용 전체**를 다시 던져줘야 알아듣습니다. 이 '대화의 족보'를 컨텍스트라고 부릅니다.
> 5.  **React**: 메타(페이스북)에서 만든 **'레고 블록 조립 세트'** 입니다. "로그인 버튼", "메뉴바" 같은 블록을 조립해서 웹사이트를 만듭니다. 가장 유명하지만 조금 무겁습니다.
> 6.  **Web Components**: React 같은 특정 브랜드 레고가 아니라, **'국제 표준 규격 벽돌'** 입니다. 브라우저 자체가 기본으로 지원하는 기능이라서, React나 Vue 같은 라이브러리 없이도 돌아갑니다. 가볍고 빠릅니다.
> 7.  **로컬 임베딩 벡터 저장 (Local Embedding Vector Storage)**:
>     *   **임베딩**: "사과"라는 글자를 `[0.1, 0.5, 0.9]` 같은 **숫자 좌표**로 바꾸는 것.
>     *   **벡터 저장**: 이 숫자를 저장해 두는 도서관.
>     *   **Why?**: AI에게 "과일 찾아줘"라고 하면, AI는 '과일'의 숫자 좌표와 가장 가까운 '사과'의 좌표를 계산해서 찾아냅니다. 이걸 내 컴퓨터(로컬)에서 한다는 뜻입니다.
>
> **💬 코치 코멘트(Sam LEE)**:
> "용어가 계속 나오지만, 깊게 파고들지 말고 **'아, 대충 이런 거구나'** 하고 넘어가세요. 계속 새로운 개념들과 경험이 쌓이다 보면, 이 낯선 용어들은 자연히 여러분의 몸속에 녹아들어 **'실력'** 이라는 형태로 나타나게 되어 있습니다. 믿고 따라오세요."

### 🛠️ [상세 가이드] 각 기술 스택 설치 및 설정 방법

초보자도 따라 할 수 있도록 각 도구의 설치 방법을 정리했습니다.

#### 1. Runtime & Manager (기반 시설)
*   **Node.js**: 자바스크립트 실행기. (건설 현장의 인부)
    *   **설치법 (macOS/Linux)**: `nvm`이나 `fnm`을 추천합니다.
        ```bash
        # fnm 설치 (Fast Node Manager)
        curl -fsSL https://fnm.vercel.app/install | bash
        # Node.js 22버전 설치
        fnm install 22
        ```
    *   **설치법 (Windows)**: 공식 홈페이지(nodejs.org)에서 LTS 버전을 다운로드하여 설치.

*   **pnpm**: 효율적인 패키지 매니저. (자재 관리 소장)
    *   **설치법**: Node.js가 깔린 상태에서 아래 명령어를 입력.
        ```bash
        npm install -g pnpm
        # 버전 확인
        pnpm -v
        ```

#### 2. Language & Framework (설계 도구)
*   **TypeScript**: 엄격한 문법 검사기. (감리사)
    *   **설치법**: 프로젝트마다 로컬로 설치하는 것이 정석입니다.
        ```bash
        pnpm add -D typescript
        ```

*   **Hono**: 초고속 웹 프레임워크. (건물 뼈대)
    *   **설치법**: 프로젝트 시작 후 설치.
        ```bash
        pnpm add hono @hono/node-server
        ```

    > [!NOTE]
    > **🛑 [배경 지식] "프로젝트 시작 후 설치"란 무슨 뜻인가요?**
    >
    > **"전입신고를(집을 계약) 해야 가구를 들여놓을 수 있습니다."**
    >
    > 우리가 인터넷 쇼핑몰에서 가구를 주문하려면, 배송받을 **'우리 집 주소'** 가 먼저 확정되어야 합니다.
    >
    > 1.  **프로젝트의 탄생(`pnpm init`)**: 이것은 컴퓨터에게 **"지금부터 이 폴더는 'OpenClaw'라는 이름을 가진 하나의 독립된 하우스(프로젝트)다!"** 라고 선포하고, 현관문에 **문패(`package.json`)** 를 다는 작업입니다.
    > 2.  **설치(`pnpm add`)**: 이제 문패가 달렸으니, 택배 기사(`pnpm`)에게 **"Hono라는 소파를 이 집 장부(`package.json`)에 등록하고 배송해주세요"** 라고 요청할 수 있게 된 것입니다.
    > 3.  **결론**: 문패(`package.json`)도 없는 허허벌판에는 택배를 시킬 수 없습니다. 그래서 항상 **"문패 달기(init) -> 가구 들이기(add)"** 순서를 지켜야 합니다.



    > [!NOTE]
    > **🏎️ [기술 해부] Hono가 도대체 뭔가요? (vs Express)**
    >
    > "웹 서버 만들 때 다들 `Express` 쓴다던데, 왜 처음 들어보는 `Hono`를 쓰나요?"
    >
    > **1. 은유(Metaphor): 중형 세단 vs F1 레이싱카**
    > *   **Express (중형 세단)**: 2010년에 나온 베스트셀러. **편안하고 익숙하지만, 무겁고 느립니다.** 엔진이 옛날 방식이라 최신 도로(Edge Computing)에서는 잘 못 달립니다.
    > *   **Hono (F1 레이싱카)**: 2022년에 나온 최신 머신. **불필요한 기능 다 떼버리고 오직 '속도'와 '표준'에만 집중**했습니다.
    >
    > **2. 결정적 차이 (Web Standard)**
    > *   **Express**: 자기들만의 독자 규격(`req`, `res`)을 씁니다. Node.js 밖으로 나가면 숨을 못 쉽니다.
    > *   **Hono**: **전 세계 웹 표준 규격(`Request`, `Response`)** 을 그대로 씁니다. Node.js뿐만 아니라 AWS, Cloudflare 어디서든 돌아갑니다. **게다가 5배 빠릅니다.**

    #### 3. Libraries (특수 부품) - 왜 이것들이 필요한가?
    
    *   **Baileys**: WhatsApp 연결 라이브러리. (해커의 무전기)
        *   **설치법**: `pnpm add @whiskeysockets/baileys`
        *   **은유(Metaphor)**: **"해커의 무전기"**. WhatsApp은 공식적으로 봇을 만드는 걸 까다롭게 굽니다(비즈니스 API 유료, 승인 절차 복잡). Baileys는 우리가 **마치 진짜 'WhatsApp 웹' 브라우저인 척** 가장해서 서버와 통신하게 해주는 무전기입니다.
        *   **Why?**: 이 "특수 부품"이 없으면 여러분은 페이스북(Meta) 본사에 사업자 등록증 내고, 승인받고, 돈을 내야 봇을 돌릴 수 있습니다. Baileys는 그 모든 과정을 건너뛰고 **"지금 당장"** 봇을 돌리게 해주는 마법의 열쇠입니다.
    
    *   **SQLite**: 데이터베이스. (캠핑용 배낭)
        *   **설치법**: `pnpm add better-sqlite3`
        *   **은유(Metaphor)**: **"캠핑용 배낭"**. 보통 DB(MySQL, Oracle)라고 하면 거대한 컨테이너 트럭을 떠올립니다. 시동 거는 데만 한 세월이죠. SQLite는 그냥 파일 하나(`database.sqlite`)가 곧 DB입니다. 가방에 쏙 들어갑니다.
        *   **Why?**: OpenClaw(Moltbot)은 라즈베리 파이 같은 작은 컴퓨터에서도 돌아가야 합니다. 덩치 큰 DB 서버를 따로 띄우는 건 사치입니다. **"파일 하나만 복사하면 이사 끝"** 인 간편함 때문에 이 특수 부품을 씁니다.

    > [!TIP]
    > **🖥️ [실습 가이드] VSCode에서 프로젝트 0부터 세팅하기 (2025년 12월 버전)**
    >
    > "명령어는 알겠는데, 도대체 **어디에** 치라는 건가요?"
    > 막막해하실 분들을 위해, 마우스 클릭 하나하나까지 다 알려드립니다. 천천히 따라오세요.
    >
    > **🤔 [잠깐] VSCode가 뭔가요? 메모장이랑 뭐가 달라요?**
    > *   **메모장(Notepad)**: 단순히 글자만 적는 **'과도(과일 깎는 칼)'** 입니다. 사과 하나 깎을 땐 좋지만, 요리는 못 합니다.
    > *   **VSCode (Visual Studio Code)**: 마이크로소프트가 만든 **'최첨단 셰프의 주방'** 입니다.
    >     *   **재료 색깔 표시**: 코드가 알록달록하죠? 소금인지 설탕인지 헷갈리지 말라고 색칠해 주는 겁니다. (Syntax Highlighting)
    >     *   **보조 셰프**: `consol`만 쳐도 `console`이라고 추천해 줍니다. (Auto-completion)
    >     *   **상황실 통합**: 코드를 짜면서 바로 서버를 켜고 끄는 버튼(터미널)이 내장되어 있습니다.
    > *   **결론**: 개발을 처음 한다면 무조건 이걸 쓰세요. 무료이고, 전 세계 개발자의 70%가 씁니다.
    >
    > ---
    >
    > **1. 폴더 만들기 (집터 닦기)**
    > *   바탕화면이나 편한 곳에 새 폴더를 만드세요. 이름은 `openclaw-lab` 정도로 지어볼까요?
    > *   이 폴더가 앞으로 우리의 **베이스캠프**가 됩니다.
    >
    > **2. VSCode 열기 (입주)**
    > *   VSCode를 실행합니다.
    > *   방금 만든 `openclaw-lab` 폴더를 마우스로 끌어서(Drag & Drop) VSCode 화면 정중앙에 놓으세요.
    > *   또는 메뉴에서 `File` -> `Open Folder...`를 눌러서 찾아도 됩니다.
    > *   왼쪽 탐색기(Explorer)에 폴더 이름이 보인다면 입주 성공입니다.
    >
    > **3. 터미널 열기 (상황실 개방)**
    > *   이제 검은 화면, **터미널(Terminal)** 을 열 차례입니다. 이곳이 바로 우리가 컴퓨터에게 직접 명령을 내리는 대화창입니다.
    > *   **단축키**: `Ctrl` + `` ` `` (물결표시 키, 맥/윈도우 공통)
    > *   **메뉴**: 상단 메뉴바 `Terminal` -> `New Terminal`
    > *   하단에 패널이 열리면서 깜빡이는 커서가 보이나요? 준비 완료입니다.
    >
    > **4. 명령 하달 (Start)**
    > *   이제 아래 명령어를 **한 줄씩 복사**해서 터미널에 붙여넣고 **엔터(Enter)** 를 치세요.
    >
    >   ```bash
    >   # 1. 호적 등본(package.json) 만들기
    >   pnpm init
    >
    >   # 2. 필수 자재(라이브러리) 주문하기
    >   pnpm add hono @hono/node-server @whiskeysockets/baileys better-sqlite3
    >
    >   # 3. 설계 도구(TypeScript) 주문하기 (개발용이라 -D 옵션 붙임)
    >   pnpm add -D typescript @types/node
    >   ```
    >
    > **5. 확인 사살 (Check)**
    > *   왼쪽 탐색기에서 `package.json` 파일을 클릭해보세요.
    > *   파일 내용이 아래와 비슷하다면 성공입니다. (버전 숫자는 조금 댤라도 괜찮습니다.)
    >
    >   ```json
    >   {
    >     "name": "openclaw-lab",
    >     "version": "1.0.0",
    >     "dependencies": {
    >       "@hono/node-server": "^1.x.x",
    >       "@whiskeysockets/baileys": "^6.x.x",
    >       "better-sqlite3": "^11.x.x",
    >       "hono": "^4.x.x"
    >     },
    >     "devDependencies": {
    >       "@types/node": "^22.x.x",
    >       "typescript": "^5.x.x"
    >     }
    >   }
    >   ```
    >
    > *   **축하합니다! 성공적으로 환경 세팅을 마치셨습니다.** 여기까지 따라오시느라 고생 많으셨습니다.
    
    ---
    



    
    ---


    
    ---

## 1. 프로젝트 초기화 (Foundation Setup)

가장 먼저 튼튼한 기반을 다집니다. 이 프로젝트는 모든 구성 요소(서버, 앱, 플러그인)가 하나의 저장소에 있는 **Monorepo** 구조를 따릅니다.

### 1-1. 환경 설정 (Micro-Process)

1.  **Node.js 설치**: `v22.12.0` 이상 필수.
2.  **pnpm 설치**: `npm install -g pnpm@10.23.0`.

    ---
    
    ### 🚨 [초보자를 위한 가이드] 왜 npm 대신 pnpm을 쓰는가? (The Revolution of pnpm)
    
    "npm도 잘 되는데 굳이 왜 이걸 또 깔아야 하나요?" 라는 질문은 매우 타당합니다. 하지만 OpenClaw(Moltbot) 같은 대규모 프로젝트(Monorepo)에서 npm을 쓰면 **재앙**이 닥칩니다.
    
    #### 1. 은유(Metaphor): 도서관 책 빌리기
    *   **npm (비효율의 끝판왕)**: 학생 100명이 "해리포터" 책을 읽어야 한다고 합시다. npm 방식은 **100권의 책을 새로 사서 각 학생의 가방에 넣어주는 것**입니다. 가방(디스크)이 터지고, 책값(설치 시간)이 엄청 듭니다.
    *   **pnpm (효율적 공유)**: 학교 도서관에 "해리포터" **딱 한 권만** 사놓습니다. 학생들에게는 책 위치가 적힌 **쪽지(Symlink)** 만 줍니다. 읽을 때는 도서관 책을 참조합니다. 100명이든 1000명이든 책은 한 권이면 됩니다.
    
    #### 2. 실제 차이 (Real World Impact)
    *   OpenClaw(Moltbot) 프로젝트는 수백 개의 라이브러리를 씁니다.
    *   **npm 사용 시**: 프로젝트를 복사할 때마다 1GB가 넘는 `node_modules` 폴더가 계속 복제됩니다. 하드디스크가 순식간에 꽉 찹니다.
    *   **pnpm 사용 시**: 100개를 복사해도 용량은 거의 늘어나지 않습니다. (Content Addressable Store 방식)
    
    #### 3. 결정적 이유 (Killer Feature): 엄격함(Strictness)
    *   **npm의 유령(Phantom Dependencies)**: npm은 내가 설치하지 않은 라이브러리도 실수로 쓸 수 있게 허용하는 버그(혹은 관대함)가 있습니다. 나중에 배포할 때 "어? 내 컴퓨터에선 되는데 서버에선 안 돼요!" 하는 지옥을 맛보게 됩니다.
    *   **pnpm**: 내가 `package.json`에 명시한 것만 정확히 쓸 수 있게 막아줍니다. **"정의되지 않은 것은 없다"** 는 철학입니다.
    
    ---

    ### 🛑 [여기서 잠깐] npm이 도대체 뭔가요? (What is npm?)

    "개발자들은 왜 자꾸 `npm npm` 거리는 걸까요?"

    #### 1. 은유(Metaphor): 개발자들의 "앱스토어" 혹은 "다이소"
    *   **아이폰 앱스토어**: 카카오톡이 필요하면 우리가 직접 코딩해서 만들지 않죠? **앱스토어**에서 다운로드 받습니다.
    *   **npm (Node Package Manager)**: 개발할 때 "달력 기능"이나 "암호화 기능"이 필요하면 직접 짜지 않고 **npm**이라는 **무료 부품 상점**에서 다운로드 받습니다.
    
    #### 2. 레고 블록 (Lego Blocks)
    *   여러분이 **"성(Castle)"** 을 만든다고 상상해 보세요.
    *   플라스틱을 녹여서 블록 하나하나를 직접 만드는 건 미친 짓입니다. (이게 npm 없이 개발하는 것)
    *   npm은 **"문", "창문", "성벽" 블록을 미리 만들어 파는 가게**입니다. 우리는 `npm install castle-wall` 명령어 한 줄로 성벽 블록을 가져와서 조립만 하면 됩니다.
    
    #### 3. 사용하는 이유 (Why?)
    *   **시간 절약**: 남들이 10년 동안 만든 검증된 코드를 1초 만에 가져와 씁니다.
    *   **검증된 품질**: 전 세계 수백만 명이 같이 고쳐나가는 코드라서, 내가 짠 코드보다 튼튼할 확률이 높습니다.

    #### 4. 사용 방법 (How?)
    터미널에 주문을 외우면 됩니다.
    *   `npm install [부품이름]`: "이 부품 우리 집(프로젝트)에 배달해 줘."
    *   `pnpm install`: "이 부품 배달해 주는데, 아까 말했듯이 더 효율적으로(도서관 방식) 배달해 줘."
    
    ---

3.  **프로젝트 생성**:

```bash
mkdir openclaw-clone
cd openclaw-clone
pnpm init
```

---

### 🚨 [초보자를 위한 가이드] 왜 코드를 짜기 전에 `tsconfig.json` 부터 건드리는가?

많은 분들이 *"일단 `server.ts` 파일 만들고 코드부터 치면 안 되나요?"* 라고 묻습니다. 결론부터 말하면, **OpenClaw(Moltbot) 같은 거대한 프로젝트에서는 불가능합니다.** 그 이유를 아주 쉽게 설명해 드립니다.

#### 1. 은유(Metaphor): 건물을 짓기 전의 "토지 용도 변경"
*   **일반적인 코딩 (HTML/JS)**: 맨땅에 텐트를 치는 것과 같습니다. 그냥 폴대(`index.html`) 꽂고 천(`script.js`) 덮으면 집이 됩니다. 규칙이 없어도 됩니다.
*   **OpenClaw(Moltbot) (TS/ESM)**: 100층짜리 마천루를 짓는 것과 같습니다. 땅을 파기 전에 **"여기는 상업지구이며, 내진 설계 기준은 7.0이고, 철근은 KS규격을 써야 한다"** 는 **법적/행정적 허가(`tsconfig.json`)** 가 먼저 떨어져야 합니다. 허가증 없이 철근(`import`)을 하나라도 세우면 공사 중지 명령(`Syntax Error`)이 떨어집니다.

#### 2. 비교(Comparison): 동네 축구 vs 월드컵
*   **동네 축구 (Legacy JS Project)**: 심판도 없고 규칙도 대충입니다. "손만 안 쓰면 돼." 바로 공 차면 됩니다.
*   **월드컵 (Modern TypeScript Project)**: 경기 시작 전에 "오프사이드 반칙 기준", "VAR 판독 여부", "교체 선수 숫자"가 룰북(`tsconfig.json`)에 정의되어야 합니다. OpenClaw(Moltbot)은 월드컵 결승전급의 엄격한 규칙 하에 돌아가는 시스템입니다.

#### 3. 실제 예시 (Real World Scenario)
만약 설정 없이 바로 코드를 짠다면?
*   **개발자**: (자신있게) `import { Server } from 'http';`
*   **컴퓨터(Node.js)**: "잠깐, `import`가 뭐죠? 저는 옛날 방식(`require`)밖에 모르는데요?" -> **에러 발생 (Crash)**
*   **개발자**: (당황하며) "어? 요즘 다 이거 쓰던데?"
*   **컴퓨터**: "그건 `tsconfig.json` 이라는 번역기가 있을 때 얘기입니다. 저한테 미리 언질을 안 주셨잖아요."

**결론**: `tsconfig.json`을 먼저 만드는 것은 컴퓨터에게 **"지금부터 우리는 최신 유행어(ESM)와 엄격한 문법(TypeScript)으로 대화할 거야. 준비해."** 라고 선전포고를 하는 것입니다. 이 합의가 없으면 단 한 줄의 코드도 실행되지 않습니다.
    
    ---

    ### 🛠️ [실전 가이드] 내 작은 프로젝트에서 `tsconfig.json` 만들기 (자동 vs 수동)
    
    "Moltbot은 대형 프로젝트라서 이미 있었지만, **맨땅에서 시작하는 나만의 작은 앱**은 어떻게 하죠?"
    
    #### 1. 자동 생성 (가장 추천하는 시작법)
    터미널에 딱 한 줄만 입력하세요. TypeScript(tsc)가 알아서 "가장 표준적인" 설정 파일을 만들어줍니다.
    
    ```bash
    npx tsc --init
    ```
    
    *   **결과**: 수많은 주석이 달린 `tsconfig.json` 파일이 뿅! 하고 생깁니다.
    *   **장점**: 각 옵션이 무엇을 의미하는지 주석으로 다 설명되어 있어서 공부하기 좋습니다. 내가 몰랐던 옵션들을 발견할 수 있습니다.
    
    #### 2. 수동 생성 및 수정 (전문가가 되는 길)
    자동 생성된 파일은 "범용적"입니다. 하지만 OpenClaw(Moltbot)처럼 **고성능/최신 기술**을 쓰려면 몇 가지를 고쳐줘야 합니다.
    
    *   **어디서부터 시작하나요?**: 프로젝트의 **루트 디렉토리** (package.json이 있는 곳)에 파일을 만드세요.
    *   **무슨 근거로 값을 정하나요? (The Rationale)**:
        1.  **`target` (문법 수준)**: "내 서버의 Node.js 버전이 몇인가?"
            *   Node 14 쓰면? -> `ES2020` (Node 14가 알아듣는 한계)
            *   Node 20+ 쓰면? -> `ES2022` (최신 기능 다 써도 됨, 빠름)
        2.  **`module` (소통 방식)**: "나는 최신식인가, 구식인가?"
            *   요즘 대세 -> `NodeNext` (ESM 기반, OpenClaw(Moltbot)이 쓰는 것)
            *   옛날 호환 -> `CommonJS`
        3.  **`strict` (엄격함)**: "미래의 나를 믿는가?"
            *   `true`: "나는 나를 못 믿는다. 컴파일러야, 조금이라도 이상하면 다 잡아내라." (**강력 추천**, 나중에 프로젝트 커져도 리팩토링 비용 0원)
            *   `false`: "귀찮아, 대충 짜고 나중에 고칠게." (나중에 프로젝트 커지면 지옥 펼쳐짐)

    **요약**: 작은 프로젝트라도 `npx tsc --init`으로 시작하고, `target: ES2022`, `module: NodeNext`, `strict: true` 이 세 가지만 켜주세요. 그러면 나중에 구글, 페이스북급으로 프로젝트가 커져도 끄떡없습니다.

    ---

4.  **TypeScript 설정 (`tsconfig.json`) - 아키텍처 심층 분석**:

    이 설정 파일은 프로젝트의 **"법전(宪法)"**과 같습니다. 단순한 설정이 아니라, 이 프로젝트가 **모던 자바스크립트 생태계(ESM)** 에서 어떻게 살아남을지를 정의합니다.

    *   **코드 (원본 Source Code)**:
        ```json
        {
          "compilerOptions": {
            "target": "ES2022",
            "module": "NodeNext",
            "moduleResolution": "NodeNext",
            "outDir": "dist",
            "rootDir": "src",
            "strict": true,
            "esModuleInterop": true,
            "forceConsistentCasingInFileNames": true,
            "skipLibCheck": true,
            "resolveJsonModule": true,
            "noEmitOnError": true,
            "allowSyntheticDefaultImports": true
          },
          "include": ["src/**/*"],
          "exclude": [
            "node_modules",
            "dist",
            "src/**/*.test.ts",
            "src/**/*.test.tsx",
            "src/**/test-helpers.ts"
          ]
        }
        ```

    *   **🔬 초정밀 분석 (Micro-Analysis)**:

        *   **[1] `target`: "ES2022"**
            *   **의미**: "결과물(JS)이 2022년도 표준 문법을 사용해라."
            *   **Why?**: Node.js 18+ 버전부터는 `Top-level await`(비동기 함수 밖에서 await 쓰기), `Class properties` 같은 최신 기능을 **네이티브**로 지원합니다. 굳이 옛날 문법(ES5)으로 바구면 코드가 길어지고 느려집니다. 서버 전용 프로젝트이므로 브라우저 호환성 걱정 없이 최신 문법을 써서 **성능 최적화**를 합니다.

        *   **[2] `module` & `moduleResolution`: "NodeNext" (★ 가장 중요)**
            *   **의미**: "Node.js의 최신 모듈 해석 규칙을 엄격하게 따라라."
            *   **배경**: 자바스크립트는 역사적으로 `require()`를 쓰는 **CJS(CommonJS)** 와 `import`를 쓰는 **ESM(ECMAScript Modules)** 진영으로 나뉘어 전쟁 중이었습니다. 최신 라이브러리들(Hono, Baileys, Chalk 5+)은 이제 **ESM만 지원(Pure ESM)** 합니다.
            *   **Why?**: 만약 이 설정을 안 하면, `import { makeWASocket } from 'baileys'` 할 때 "모듈을 찾을 수 없습니다"라는 에러가 터집니다. NodeNext 모드는 `.ts` 파일이 컴파일될 때 확장자를 `.js`로 붙일지 `.mjs`로 붙일지, `package.json`의 `exports` 필드를 어떻게 읽을지를 결정합니다. **이것이 없으면 프로젝트 자체가 시작되지 않습니다.**

        *   **[3] `strict`: true**
            *   **의미**: "조금이라도 애매하면 에러를 뱉어라."
            *   **Why?**: `null`이나 `undefined`가 될 수 있는 변수를 체크 안 하고 쓰면 런타임에 서버가 죽습니다. TypeScript가 코딩 단계에서 **"너 이거 null 일 수도 있어!"**라고 멱살을 잡게 만드는 설정입니다. 대규모 프로젝트의 **안전벨트**입니다.

        *   **[4] `outDir`: "./dist"**
            *   **의미**: "번역된 JS 파일은 `dist` 폴더에 몰아 넣어라."
            *   **구조적 이유**: 소스(`src`)와 결과물(`dist`)을 분리해야, 나중에 Docker 이미지를 만들 때 `dist`만 쏙 복사해서 배포하기 좋습니다. (이미지 크기 최소화)

    *   **🚦 시작점(Entry Point)과의 연결**:
        이 설정은 `package.json`의 `"type": "module"` 설정과 세트입니다.
        1.  Node.js가 실행되면 `package.json`을 보고 "아, 이 프로젝트는 ESM이구나"라고 인식합니다.
        2.  `tsconfig.json`의 `NodeNext` 규칙에 따라 `import` 구문을 해석합니다.
        3.  `server.ts`에서 `Hono`를 import 할 때, `node_modules/hono/dist/index.mjs`를 정확히 찾아냅니다.


---

## 2. Gateway Server 구축 (The Nervous System)

Gateway는 단순한 서버가 아닙니다. 모든 데이터(메시지, 명령)가 지나가는 **고속도로이자, 시스템의 중추 신경망**입니다.

### 2-0. [심층 분석] 왜 굳이 "Gateway" 구조를 선택했는가? (Developer's Intent)

개발자가 단순히 API 서버를 만들지 않고 `Gateway` 패턴을 도입한 데에는 명확한 **건축학적 의도(Architectural Intent)** 가 있습니다.

1.  **추상화와 통일 (The Universal Translator)**:
    *   **문제**: WhatsApp은 `JID`를 쓰고, Slack은 `channel_id`를 쓰고, Telegram은 `chat_id`를 씁니다. 메시지 포맷도 제각각(JSON 구조 상이)입니다. 에이전트(LLM)가 이 모든 차이를 알게 하면 코드가 지옥이 됩니다.
    *   **해결**: Gateway는 들어오는 모든 요청을 **"표준화된 내부 이벤트(Normalized Events)"** 로 변환합니다. 에이전트는 상대방이 WhatsApp인지 슬랙인지 알 필요 없이 오직 **"메시지가 왔다"** 는 사실만 처리하면 됩니다.

    > [!NOTE]
    > **🎓 개념 수업: 추상화(Abstraction)가 도대체 뭔가요?**
    >
    > "추상화"라는 말이 어렵게 느껴지시나요? 사실 우리는 태어날 때부터 추상화를 하며 살고 있습니다.
    >
    > **1. 정의 (Definition)**
    > *   **사전적 의미**: 중요한 특징만 남기고, 불필요한 세부 사항을 지우는 것.
    > *   **코딩적 의미**: **"복잡한 내부 원리는 숨기고, 단순한 사용법(버튼)만 노출하는 것"**
    >
    > **2. 은유 (Metaphor): 자동차 운전**
    > *   **구체화 (Anti-Abstraction)**: 엑셀을 밟을 때마다 "연료 밸브를 30도 열고, 공기 흡입량을 10% 늘리고, 스파크 플러그를 점화해라"라고 직접 기계 조작을 해야 한다면? 아무도 운전을 못 할 겁니다.
    > *   **추상화 (Abstraction)**: 그냥 **"오른쪽 페달을 밟으면 -> 앞으로 간다"** 라는 사실만 알면 됩니다. 내부 엔진이 휘발유인지 전기인지는 몰라도 됩니다. 이 "페달"이 바로 추상화의 결과물입니다.
    >
    > **3. 코드 예시 (Code Example)**
    > *   **나쁜 코드 (구체적)**: 커피 타는 과정을 일일이 다 적음.
    >     ```javascript
    >     // 물 끓이기
    >     water.temperature = 100;
    >     // 원두 갈기
    >     beans.grind();
    >     // 내리기
    >     filter.pour(water);
    >     // 컵에 담기
    >     cup.fill();
    >     ```
    > *   **좋은 코드 (추상화)**: "커피 주세요" 한 마디면 됨.
    >     ```javascript
    >     makeCoffee(); // 끝. (내부에서 무슨 일이 일어나는지는 이 함수를 만든 사람만 알면 됨)
    >     ```
    >
    > **4. 개발자의 지침 (Guideline)**
    > 앞으로 코드를 짤 때 항상 스스로에게 물어보세요.
    > **"내가 만든 이 코드를 쓸 동료(혹은 미래의 나)에게 이 복잡한 과정을 다 설명해야 하나? 아니면 버튼 하나(`startGatewayServer`)만 쥐여주면 되나?"**
    >
    > 버튼 하나만 쥐여주는 것, 그것이 바로 **"추상화를 잘하는 개발자"** 입니다.

2.  **결합도 감소 (Decoupling)**:
    *   **의도**: "뇌(Agent)"와 "입/귀(Channel)"를 완벽하게 분리합니다.
    *   **효과**: 나중에 `Discord` 채널을 추가하고 싶을 때, Gateway에 플러그인만 끼우면 됩니다. 에이전트 코드는 단 한 줄도 수정할 필요가 없습니다. 이것이 **Micro-Kernel 아키텍처**의 핵심입니다.

3.  **상태 및 세션 중앙 관리 (Centralized State)**:
    *   LLM은 "기억"이 없습니다. 사용자의 대화 맥락(Context)을 저장하고, 적절한 시점에 잘라서(Pruning) LLM에 넣어주는 **기억 관리자 역할**을 Gateway가 중앙 통제합니다.

### 2-0-1. [비교 분석] 게이트웨이 말고 다른 방법은 없나요? (Architectural Alternatives)

"꼭 이렇게 복잡하게 해야 하나요? 더 쉬운 방법은 없나요?"

#### 1. 모놀리식 (Monolithic) - "원맨밴드 스타일"
*   **방식**: `server.ts` 파일 하나에 WhatsApp 코드, LLM 코드, 웹사이트 코드를 다 때려 넣는 방식.
*   **은유(Metaphor)**: **북 치고 장구 치는 1인 서커스단**. 혼자서 다 하니까 합을 맞출 필요가 없어 시작은 빠릅니다.
*   **문제점**: "피아노(Discord)"를 추가하려면? 서커스단원 전체가 악기 배우느라 공연을 멈춰야 합니다. 코드가 3,000줄 넘어가면 본인도 못 알아봅니다.

#### 2. 직접 연결 (Point-to-Point) - "칵테일 파티 스타일"
*   **방식**: AI 에이전트가 WhatsApp 서버, Slack 서버, Telegram 서버에 각각 따로따로 말을 거는 방식.
*   **은유(Metaphor)**: **통역사 없는 국제시장**. AI가 독일어(WhatsApp), 영어(Slack), 러시아어(Telegram)를 다 배워야 합니다.
*   **문제점**: 카카오톡 하나 추가할 때마다 AI 뇌수술을 다시 해야 합니다. (유지보수 지옥)

#### 3. 게이트웨이 (Gateway) - "인천공항 스타일" (우리의 선택)
*   **방식**: 모든 손님(메시지)은 일단 공항(Gateway)으로 옵니다. 공항에서 검역(Validation)하고, 표준 비자(Standardized Event)를 발급해서 입국시킵니다.
*   **승리 요인**: AI는 "공항에서 온 손님"만 상대하면 됩니다. 그 손님이 미국에서 왔든 달나라에서 왔든 신경 쓸 필요가 없습니다. **이것이 100년 가는 소프트웨어의 비밀입니다.**

### 2-0-2. [구조도] Gateway 해부도 및 조립 순서 (Gateway Anatomy)

"파일이 너무 많아요! 어디서부터 건드려야 하죠?"
걱정 마세요. 100개가 넘는 파일 중, **핵심 장기(Core Organs)** 5개만 알면 살아있는 서버를 만들 수 있습니다.

#### 1. 핵심 파일 구조 (The Skeleton)
```text
src/gateway/
├── server.ts              # [1] 얼굴 (Face): 외부에서 부르는 이름표 (Entry Point)
├── server.impl.ts         # [2] 뇌 (Brain): 모든 장기를 연결하고 명령을 내리는 곳
├── server-http.ts         # [3] 입 (Mouth): HTTP 요청(웹사이트 접속)을 처리
├── server-ws-runtime.ts   # [4] 귀 (Ears): WebSocket 요청(실시간 대화)을 처리
└── server-channels.ts     # [5] 팔다리 (Limbs): 카톡, 슬랙 같은 실제 도구들을 관리
```

#### 2. 똑같이 따라 만드는 순서 (Cloning Order)
무작정 복사하면 에러가 100개 뜹니다. **의존성(Dependency)** 순서대로 조립해야 합니다.

1.  **기초 공사**: `server.ts` (껍데기 만듦)
2.  **골격 조립**: `server.impl.ts` (핵심 로직 껍데기)
3.  **호흡기 연결**: `server-http.ts` (Hono 연결)
4.  **신경망 연결**: `server-ws-runtime.ts` (WebSocket 연결)
5.  **팔다리 부착**: `server-channels.ts` (Baileys 연결)

#### 2-0-3. [초심자를 위한 멘탈 관리] 코드를 다 쳐야 하나요? (The Mindset)

"이 많은 걸 언제 다 치고 앉아있나요? 그러다가 지쳐서 포기하면 어떡하죠?"

**절대 다 치지 마세요.** 여러분의 목표는 '타자 연습'이 아니라 **'구조 이해(Architectural Understanding)'** 입니다.

1.  **코끼리를 먹는 법 (How to Eat an Elephant)**:
    *   **전략**: 한 번에 한 입씩. 전체 코드를 다 이해하려 들지 마세요.
    *   **"블랙박스 이론"**: `loadConfig()` 함수가 있다? "아, 설정 불러오는 놈이구나" 하고 넘어가세요. 그 안에서 `fs.readFile`을 쓰는지 `Bun.file`을 쓰는지 지금 알 필요 없습니다. **큰 흐름(Flow)** 만 잡으세요.

2.  **복붙(Ctrl+C, V)은 죄가 아닙니다**:
    *   단, **"읽고(Read) -> 이해하고(Understand) -> 붙여넣으세요(Paste)"**.
    *   무지성 복붙은 독이지만, 구조를 파악하고 "이 덩어리는 여기 필요해"라고 알고 붙여넣는 건 **'조립(Assembly)'** 입니다. 이미 있는 레고 블록을 다시 깎을 필요는 없습니다.

3.  **AI를 '개인 과외 선생님'으로 쓰세요**:
    *   "이 코드 500줄 다 설명해줘" (X) -> 너무 많아서 눈에 안 들어옵니다.
    *   **"이 파일에서 가장 중요한 함수 3개만 꼽아서, 각각 무슨 일을 하는지 한 줄로 요약해줘"** (O) -> 핵심 뼈대만 머리에 넣으세요.

#### 2-0-4. [준비물] 해설자 모드 장착하기 (The Narrator)

"작동하는 코드가 아니라, **스스로 설명하는 코드**를 만드세요."

여러분이 작성할 첫 번째 파일은 서버 코드가 아닙니다. 바로 **로그 파일에 자기소개를 남기는 도구**입니다. 이 도구를 쓰면, 프로그램이 실행될 때마다 마치 영화 해설처럼 로그가 남습니다.

**파일 생성**: `src/narrator.ts`

```typescript
import fs from 'fs';

// "해설자" 함수: 누가, 어디서, 누구에게 연락하는지 기록합니다.
export function narrate(info: {
  who: string;      // 함수 이름 (예: startGatewayServer)
  role: string;     // 역할 (예: 총사령관)
  action: string;   // 하는 일 (예: 심장 박동기 켜기)
  friend?: string;  // 연결 대상 (예: startHeartbeatRunner)
}) {
  const logMessage = `[${new Date().toISOString()}] 
  👤 WHO: ${info.who}
  🛡️ ROLE: ${info.role}
  🎬 ACTION: ${info.action}
  ${info.friend ? `🔗 CONTACT: ${info.friend}` : ""}
  --------------------------------------------------\n`;

  // 1. 화면에 보여주기
  console.log(logMessage);
  
  // 2. 파일에 기록하기 (learning.log)
  fs.appendFileSync('learning.log', logMessage);
}
```

이제부터 모든 함수를 만들 때, 로직 대신 이 `narrate()` 함수를 맨 앞에 박아둘 겁니다.

---

### 2-1. [확대 분석] 서버 진입점 생성 (`src/gateway/server.ts`) - **[단계 1: 기초 공사/얼굴]**

가장 먼저 이 파일을 만듭니다. 이 파일은 서버의 **"안내 데스크(Front Desk)"** 입니다.

#### 2-1-1. [초정밀 해부도] Front Desk Map
오시다시피 이 파일은 **아무런 로직이 없습니다.** 오직 다른 파일로 연결만 해줍니다. 이것을 디자인 패턴에서는 **퍼사드 패턴(Facade Pattern)** 이라고 합니다.

```text
[외부 세상: CLI, Docker]
       ⬇️ (접속: "서버 켜줘!")
       ⬇️
src/gateway/server.ts (안내 데스크)
       │
       ├── 1. "사장실 연결해 드립니다." (startGatewayServer)
       │       ⤷ 연결 ➡ src/gateway/server.impl.ts (진짜 CEO: 뇌)
       │
       ├── 2. "보안 규정집 여기 있습니다." (truncateCloseReason)
       │       ⤷ 연결 ➡ src/gateway/server/close-reason.ts (규정집)
       │
       └── 3. "명함 양식입니다." (GatewayServer Type)
               ⤷ 연결 ➡ src/gateway/server.impl.ts (타입 정의)
```

#### 2-1-2. 코드 씹어먹기 (Code Anatomy)
`src/gateway/server.ts`

```typescript
// [1] 보안 요원 연결 (Security)
// 역할: 웹소켓 연결 끊을 때 이유가 너무 길면(해킹 시도 등) 적당히 자르는 함수를 내보냅니다.
export { truncateCloseReason } from "./server/close-reason.js";

// [2] 명함(Type) 공유 (Public Card)
// 역할: "우리 사장님(GatewayServer)은 이렇게 생겼습니다"라고 외부에 알려줍니다.
export type { GatewayServer, GatewayServerOptions } from "./server.impl.js";

// [3] 사장실 연결 (The Real Boss)
// 핵심: 실제로 서버를 켜는 함수(startGatewayServer)를 밖으로 내보냅니다.
// 외부(CLI)에서는 이 파일의 startGatewayServer만 호츨하면, 내부 사정을 몰라도 서버가 켜집니다.
export { __resetModelCatalogCacheForTest, startGatewayServer } from "./server.impl.js";
```

#### 2-1-3. [TS 문법 교실] 이게 무슨 뜻인가요? (Grammar Class)

초보자가 가장 헷갈려 하는 3가지 문법을 **완벽하게 분해**해 드립니다.

*   **1. `export { ... } from "..."`**: **"국제 배송 대행 서비스"**
    *   **의미**: "저쪽 파일(`from`)에 있는 물건을 가져와서, 내 이름으로 다시 해외 수출(`export`)하겠다."
    *   **은유(Metaphor)**: 쿠팡(server.ts)이 삼성전자(server.impl.ts)의 냉장고를 떼와서 쿠팡 이름으로 파는 것과 같습니다. 소비자는 삼성 공장에 갈 필요 없이 쿠팡에서 사면 됩니다.

*   **2. `export type`**: **"설계도면 vs 실제 건물"**
    *   **의미**: "Java/C#의 Class나 Interface 같은 **껍데기(모양)** 만 내보냅니다."
    *   **은유(Metaphor)**:
        *   `export class` (GatewayServer): 실제 살 수 있는 **아파트**입니다. (메모리 차지함)
        *   `export type` (GatewayServer): 아파트 **설계도(청사진)** 종이입니다. (메모리 차지 안 함)
    *   **Why?**: TypeScript는 컴파일되면 JavaScript로 변합니다. 이때 `type`으로 정의된 건 **흔적도 없이 사라집니다(Ghost).** 개발할 때 자동완성 힌트만 주고, 런타임에는 가볍게 사라지기 위해 씁니다.

*   **3. `{ a, b }` (중괄호)**: **"종합 선물 세트 뜯기"**
    *   **문법 이름**: **구조 분해 할당 (Destructuring Assignment)**
    *   **의미**: "`server.impl.js`라는 큰 선물 상자 안에 여러 가지가 들어있는데, 그중에서 `__reset...`이랑 `startGatewayServer`라는 딱 2개만 콕 집어서 꺼내겠다."
    *   **예시**:
        ```typescript
        const Box = { candy: 10, chocolate: 5, gum: 3 };
        const { candy, gum } = Box; // 초콜릿은 안 꺼냄!
        ```

#### 2-1-3. [배경 지식] 왜 껍데기 파일을 따로 만드나요? (Why Facade?)

이것은 소프트웨어 공학에서 **"변경에 대한 방어막(Decoupling)"** 을 치는 기술입니다. 쉬운 예시를 들어보겠습니다.

**🏠 실생활 예시: "고객센터 대표번호 (1588-0000)"**

*   **상황**: 여러분이 쇼핑몰 CEO입니다. 전국에 흩어진 상담원들이 전화를 받습니다.
*   **껍데기(`server.ts`)**: **대표번호 1588-0000**
*   **실체(`server.impl.ts`)**: 실제 상담 센터 (처음엔 **서울** 사무실)

**🌪 사건 발생**: 서울 사무실 임대료가 비싸서 **부산**으로 이사 가기로 했습니다. (`server.impl.ts` -> `server.busan.ts` 로 파일명 변경)

1.  **대표번호가 없을 때 (No Facade)**:
    *   고객 100만 명에게 전부 문자를 보내야 합니다.
    *   *"죄송합니다. 번호가 02-123-4567에서 051-987-6543으로 바뀌었습니다. 다시 저장해주세요."*
    *   코드로 치면, 이 파일을 `import`해서 쓰는 **모든 파일 100개를 찾아서 수정**해야 합니다. (대재앙)

2.  **대표번호가 있을 때 (Facade Pattern)**:
    *   고객은 아무것도 몰라도 됩니다. 여전히 1588-0000으로 걸면 됩니다.
    *   CEO인 여러분은 **대표번호 연결 설정(Routing)** 만 서울에서 부산으로 1줄 바꾸면 끝입니다.
    *   코드로 치면, **`server.ts`의 `import` 경로 1줄만 수정**하면 프로젝트 전체가 멀쩡하게 돌아갑니다.

**결론**: `server.ts`는 귀찮은 껍데기가 아니라, 미래의 변화로부터 우리를 지켜주는 **"안전 장치"** 입니다.

#### 2-1-4. [잠깐만] 안전장치 직접 실험해보기 (Facade Lab)

"말로만 듣지 말고, **진짜 안전한지** 직접 터트려봅시다."

이 개념을 확실히 잡고 가기 위해, 아주 간단한 **실험실(Lab)** 을 만들어보겠습니다. 폴더 아무데나 `test-facade` 폴더를 만들고 3개의 파일을 만드세요.

**1. `core-v1.js` (실체: 구형 엔진)**
```javascript
// 실제 로직이 들어있는 파일
export function startEngine() {
  console.log("🚗 V1 엔진: 부릉부릉 (시끄러움)");
}
```

**2. `gateway.js` (껍데기: 안전장치)**
```javascript
// 여기가 핵심입니다! 실체를 import해서 그대로 내보냅니다.
export * from "./core-v1.js"; 
```

**3. `client.js` (사용자: 운전자)**
```javascript
// 운전자는 'core-v1.js'를 모릅니다. 오직 'gateway.js'만 압니다.
import { startEngine } from "./gateway.js";

console.log("👤 운전자: 시동을 겁니다.");
startEngine();
```

---

**🧪 실험 시작: 미래를 바꾸는 시나리오 4단계**

**1단계: 평화로운 일상 (Initial Run)**
먼저 터미널에서 `node client.js`를 입력해서 실행해 보세요.
화면에 **"🚗 V1 엔진: 부릉부릉"** 하고 시끄러운 소리가 날 겁니다.
지금 운전자(`client.js`)는 `gateway.js`를 통해 구형 엔진을 쓰고 있습니다. 평화롭죠?

**2단계: 위기 발생 (Refactoring Needed)**
어느 날, 정부에서 "소음 규제"를 발표합니다. 더 이상 시끄러운 V1 엔진을 쓸 수 없게 되었습니다.
자, 이제 `core-v1.js` 파일을 과감하게 **삭제**해 버리세요. 그리고 **`core-v2.js`** 라는 새 파일을 만들고 아래 코드를 넣습니다.
```javascript
export function startEngine() {
  console.log("⚡️ V2 모터: 위이잉 (조용함)");
}
```
이제 실체(엔진)가 완전히 바뀌어 버렸습니다.

**3단계: 마법의 방어 (The Fix)**
보통 같으면 운전자(`client.js`) 코드를 뜯어고쳐야겠지만, 우리는 그럴 필요가 없습니다.
중간에 있는 **`gateway.js`** 파일만 살짝 여세요. 그리고 `from` 뒤에 있는 경로만 바꿔주면 됩니다.
```javascript
export * from "./core-v2.js"; // v1 -> v2 로 숫자 하나만 바꿨습니다.
```
운전자 몰래, 카센터 사장님(Gateway)이 엔진을 최신형으로 바꿔치기한 겁니다.

**4단계: 결과 확인 (Verification)**
다시 `node client.js`를 실행해 보세요.
놀랍게도 운전자는 아무런 에러 없이 **"⚡️ V2 모터: 위이잉"** 하고 전기차를 몰게 됩니다.
운전자는 엔진이 바뀐 줄도 모릅니다. 단지 차가 조용해졌다고 좋아할 뿐이죠.

**🎓 결론: 이것이 바로 '유지보수'입니다**
여러분이 방금 하신 일이 바로 **"의존성 분리(Decoupling)"** 입니다.
내무 부품이 싹 다 바뀌어도, 바깥세상(Client)에는 충격을 주지 않는 것. 이것이 시니어 개발자들이 `server.ts` 같은 껍데기 파일을 굳이 만들어 두는 이유입니다.

> [!IMPORTANT]
> **🚀 이 책(매뉴얼)의 최종 목표**
> 비록 지금은 초보자일지라도, 이런 고급 아키텍처 경험을 하나하나 빠르게 쌓아서 **"시니어 개발자의 통찰력"** 을 갖추는 것이 목표입니다.
> 그래야만 단순히 AI가 짜주는 코드를 받아 적는 것을 넘어, **AI 코딩 에이전트들을 내 손바닥 위에서 자유자재로 지휘하고 주무르는** 진짜 사령관이 될 수 있습니다.

---




---

### 2-2. [확대 분석] 서버 뇌 구현 (`src/gateway/server.impl.ts`) - **[단계 2: 골격 조립]**

안내 데스크(`server.ts`)의 문을 열고 들어오셨군요. 환영합니다.
이곳은 OpenClaw(Moltbot) 시스템의 가장 깊숙한 곳, **"종합 상황실(NASA Control Room)"** 입니다.

눈앞에 펼쳐진 **약 600줄의 코드**가 위압적으로 느껴지십니까? 당연합니다.
이곳은 단순한 코드가 아닙니다. 서버의 오감을 깨우고, 인공지능 두뇌를 연결하고, 전 세계와 통신하는 신경망을 지휘하는 **"사령부"** 이기 때문입니다.

*   **좌측 스크린**: `HTTP Server`가 웹에서 들어오는 신호를 감시합니다.
*   **우측 스크린**: `WebSocket`이 수천 개의 실시간 연결을 유지합니다.
*   **중앙 콘솔**: `Agent Runner`가 AI(GPT-4)에게 끊임없이 명령을 내립니다.
*   **백그라운드**: `Heartbeat`가 시스템의 생명 반응을 주기적으로 체크합니다.

이 모든 것이 단 하나의 파일, `server.impl.ts` 안에서 조율됩니다.
복잡해 보이지만 걱정하지 마십시오. 우리는 이 거대한 우주선을 **"단 5개의 버튼"** 으로 분해해서 하나씩 조립할 것입니다.

준비되셨나요? 이제 사령관(`startGatewayServer`)의 의자에 앉아 볼 시간입니다.

#### 2-2-0. [공급망 분석] import 목록 73줄, 어떻게 처리하나요? (Supply Chain)

"import가 70줄이나 되는데, 이걸 다 만들어야 하나요?"
네, 하지만 **"내용"을 다 만들 필요는 없습니다.** 껍데기(Stub)만 있으면 됩니다. 이 70줄은 크게 5가지 그룹으로 나뉩니다.

*   **1. 외부 기관 (External Agencies)**:
    *   `../config/*`: 설정 파일 등본을 떼오는 곳.
    *   `../infra/*`: 진단(Diagnostic), 심장 박동(Heartbeat), 재시작(Restart) 등 생명 유지 장치.
    *   `../logging/*`: 블랙박스 기록 장치.
*   **2. 에이전트 본부 (Agent HQ)**:
    *   `../agents/*`: AI 두뇌 관리소.
*   **3. 내부 장기 (Internal Organs)**:
    *   `./server-*`: HTTP, WS, Channel 등 서버의 실제 부품들.

**💡 [핵심 전략] "가짜로 채워라 (Fake it till you make it)"**
70개 파일을 다 구현하다간 지쳐 떨어집니다. **"빈 파일 전략(Stubbing)"** 을 쓰세요.

1.  **빨간 줄 없애기 게임**: `server.impl.ts`를 복사해서 붙여넣으면 온통 빨간 줄(에러)입니다.
2.  **빈 파일 생성**: 에러가 나는 경로(예: `../infra/heartbeat.ts`)에 파일을 만듭니다.
3.  **가짜 수출(Export)**: 함수 내용을 비워두고 `export`만 하세요.
    ```typescript
    // ../infra/heartbeat.ts
    // 껍데기만 만듭니다. 내용은 나중에 채웁니다.
    export function startHeartbeatRunner() { console.log("Heartbeat started (fake)"); }
    ```
4.  **컴파일 성공**: 빨간 줄이 다 사라지면, 서버는 켜집니다. (물론 아무 기능도 안 하겠지만, 골격은 완성된 겁니다.)

#### 2-2-1. [상세 분석] 함수 명예의 전당 (Function Hall of Fame)

> [!QUESTION]
> **Q. 사령관님, 질문 있습니다!**
> "`server.impl.ts`의 90~92번째 줄을 봤는데, `GatewayServer` 타입이 너무 심플합니다. 고작 `close` 함수 하나밖에 없는데요?"
>
> ```typescript
> export type GatewayServer = {
>   close: (opts?: ...) => Promise<void>;
> };
> ```
>
> **A. 전문가의 통찰력 (Expert's Insight)**
> 아주 날카로운 질문입니다! 여기서 우리는 **"추상화의 미학(The Art of Abstraction)"** 을 배워야 합니다.
>
> 1.  **빙산의 일각 (Tip of the Iceberg)**:
>     *   빙산은 물 위에 10%만 보이고, 물 밑에 90%가 숨어 있죠.
>     *   `GatewayServer`는 물 위에 나온 10%입니다. 외부(CLI)에서는 서버를 "켜고(start)", "끄는(close)" 것 외에는 알 필요가 없게 만든 것입니다. 내부에서 100만 줄의 코드가 돌아가든 말든, 사용자는 **"전원 버튼"** 하나면 충분합니다.
>
> 2.  **핵가방 (Nuclear Football)**:
>     *   대통령의 핵가방에는 복잡한 미사일 회로가 들어있지 않습니다. 오직 **"발사 버튼"** 과 **"취소 버튼"** 만 있습니다.
>     *   만약 리모컨에 버튼이 100개라면(예: `server.http`, `server.ws` 다 노출), 사용자는 헷갈려서 사고를 칠 겁니다.
>     *   **"가장 훌륭한 인터페이스는 더 이상 뺄 것이 없는 상태다."** 이 단순함이 바로 고수가 설계했다는 증거입니다.

각 함수의 역할과, 초보자가 이를 어떻게 복제(Cloning)해야 하는지 하나씩 뜯어보겠습니다.

##### 1. `loadConfig` (보급관: 엄격한 세관원)
*   **역할**: `config.yaml` 파일을 읽어서 자바스크립트 객체로 변환합니다. 그냥 읽는 게 아니라, **"빠진 항목은 없는지, 타입은 맞는지"** 검사(Validation)합니다.
*   **입력(Input)**: `CONFIG_PATH` (파일 경로 문자열)
*   **출력(Output)**: `ClawdbotConfig` (검증된 설정 객체) 또는 **에러 폭발(Throw Error)**
*   **코드 분석**:
    ```typescript
    // 실제 로직 (Zod 라이브러리 사용)
    const raw = fs.readFileSync("config.yaml"); // 1. 파일 읽기
    const parsed = yaml.parse(raw);             // 2. 파싱
    const config = ClawdbotSchema.parse(parsed); // 3. 검증 (여기서 틀리면 에러!)
    return config;
    ```
*   **초보자 클론 전략 (Stub First)**:
    *   **Stub Code**:
        ```typescript
        import { narrate } from "../narrator";

        export function loadConfig() {
            narrate({ 
                who: "loadConfig", 
                role: "보급관", 
                action: "설정 파일 로딩 시늉" 
            });
            return { agents: { defaults: { model: "gpt-4" } } };
        }
        ```

##### 2. `startHeartbeatRunner` (의무병: 자동 심장충격기)
*   **역할**: 주기적으로(예: 1시간마다) 봇이 살아있는지 확인하고, 필요하면 자가 진단 메시지를 보냅니다. "활동 시간(Active Hours)"인지 체크해서 밤에는 조용히 시킵니다.
*   **입력(Input)**: `Config` (설정 객체)
*   **출력(Output)**: `HeartbeatRunner` (멈춤 버튼 `stop()`이 달린 handle)
*   **초보자 클론 전략 (Stub First)**:
    *   **Stub Code**:
        ```typescript
        import { narrate } from "../narrator";

        export function startHeartbeatRunner() {
            narrate({ 
                who: "startHeartbeatRunner", 
                role: "의무병", 
                action: "심장 박동기 가동" 
            });
            return { stop: () => { console.log("MEDIC: Stopped"); } };
        }
        ```

##### 3. `createChannelManager` (외교관: 만국 공통어 통역사)
*   **역할**: WhatsApp, Slack, Discord 등 서로 다른 언어를 쓰는 외부 채널들을 관리합니다. 각 채널을 켜고(`start`), 끄고(`stop`), 상태를 확인하는 제어판입니다.
*   **입력(Input)**: `ChannelManagerOptions` (로그, 설정 등)
*   **출력(Output)**: `ChannelManager` (채널 제어 메서드 모음)
*   **초보자 클론 전략 (Stub First)**:
    *   **Stub Code**:
        ```typescript
        import { narrate } from "../narrator";

        export function createChannelManager() {
            return {
                startChannels: async () => { 
                    narrate({ 
                        who: "startChannels", 
                        role: "외교관", 
                        action: "모든 대사관(WhatsApp, Slack) 연결" 
                    });
                }
            };
        }
        ```

##### 4. `createHttpServer` (대변인: 기자회견장)
*   **역할**: 외부에서 들어오는 요청(HTTP Request)을 받아서 적절한 담당자에게 토스합니다.
    *   `/v1/hooks` -> `hooks.ts` (웹훅 담당)
    *   `/slack/events` -> `slack.ts` (슬랙 담당)
    *   `/ui` -> `control-ui.ts` (관리자 화면 담당)
*   **입력(Input)**: `handleHooksRequest`, `controlUiEnabled` 등 (각 부서의 연락처)
*   **출력(Output)**: `HttpServer` (Node.js 서버 객체)
*   **초보자 클론 전략 (Stub First)**:
    *   **Stub Code**:
        ```typescript
        import { Hono } from "hono";
        import { narrate } from "../narrator";
        
        export function createHttpServer() {
            const app = new Hono();
            app.get("/", (c) => {
                narrate({ 
                    who: "HttpHandler", 
                    role: "대변인", 
                    action: "기자(Client) 질문 응대" 
                });
                return c.text("SPOKESPERSON: I am ready.");
            });
            return app;
        }
        ```

##### 5. `attachGatewayWsHandlers` (통신병: 전화선 개통)
*   **역할**: 들어오는 소켓 연결(`connection`)을 감지하고, "누구십니까(Auth)"를 물어보고, "연결되었습니다" 도장을 찍어주는 수문장입니다.
*   **입력(Input)**: `wss` (웹소켓 서버), `clients` (접속자 명단)
*   **출력(Output)**: `void` (돌려주는 것 없음. 그냥 전화선만 꽂아둠)
*   **초보자 클론 전략 (Stub First)**:
    *   **Stub Code**:
        ```typescript
        import { narrate } from "../narrator";

        export function attachGatewayWsHandlers({ wss }) {
            wss.on("connection", (ws) => {
                narrate({ 
                    who: "WsHandler", 
                    role: "통신병", 
                    action: "새로운 전화 연결 수락" 
                });
            });
        }
        ```

> [!TIP]
> **"Stubbing(껍데기 만들기)"** 은 초보자의 꼼수가 아니라, 시니어 개발자가 복잡도를 관리하는 **가장 프로페셔널한 기술**입니다. 
> 700줄을 한 번에 짜는 사람은 세상에 없습니다. 위에서 알려드린 **5개의 껍데기 함수**만 먼저 파일에 복붙하고, `startGatewayServer` 안에서 호출만 해보세요. **에러 없이 실행되는 기쁨**을 먼저 맛보셔야 합니다.

#### 2-2-2. [AI 시대의 코딩] TypeScript 문법, 굳이 배워야 하나요?

"AI가 코드 다 짜주는데, 문법 공부를 해야 하나요?"
**네, 하지만 관점이 달라야 합니다.** 직접 코딩하기 위해서가 아니라, **AI에게 정확히 지시하기 위해서** 배워야 합니다.

*   **1. Interface/Type = "AI에게 내리는 스펙(Spec)"**
    *   **과거**: 내가 코딩하다 틀리면 컴파일러한테 혼나려고 씀.
    *   **AI 시대**: **"야 AI야, 네가 짤 함수는 반드시 이 모양이어야 해!"** 라고 규격(Spec)을 던져주는 용도.
    *   **전략**: 구현(`function`)보다 타입(`interface`)을 먼저 정의하고 AI에게 던지세요. 그러면 AI가 딴소리를 못 합니다.

*   **2. Promise/Async = "AI야, 잠깐만 기다려"**
    *   **과거**: 비동기 처리가 어려워서 콜백 지옥에 빠짐.
    *   **AI 시대**: "이 작업은 오래 걸리니까(`async`), 다 될 때까지 기다렸다가(`await`) 다음 줄로 넘어가" 라는 **업무 순서 지시서**입니다.

#### 2-2-3. [실전 클론 가이드] AI를 부려먹는 법 (How to Command)

이 복잡한 파일을 혼자 짜지 마세요. 이렇게 지시하십시오.

1.  **스텝 1: 빈 껍데기 요청 (Stubbing)**
    > "server.impl.ts의 `startGatewayServer` 함수 뼈대만 만들어줘. 내부는 비워두고, 리턴 타입인 `GatewayServer`만 맞춰줘."
2.  **스텝 2: 설정 로직 주입 (Dependency Injection)**
    > "방금 만든 함수 맨 윗줄에 `loadConfig`를 호출해서 설정을 불러오는 로직만 추가해줘. `loadConfig`는 없는 함수니까 import 문만 적어놔."
3.  **스텝 3: 서브시스템 연결 (Connectivity)**
    > "이제 `createHttpServer`와 `createWebSocketServer`를 호출하는 코드를 중간에 넣어줘."

**핵심**: AI에게 한 번에 "이거 다 만들어"라고 하지 말고, **"조립 설명서의 한 문장"** 씩 던지세요. 그것이 진짜 엔지니어의 실력입니다.

#### 2-2-4. [TS 문법 심화] 'GatewayServer' 타입 완전 해부

사용자님이 질문하신 `GatewayServer` 타입 정의를 한 줄 한 줄 뜯어보겠습니다. 이것은 **"서버 리모컨의 사용 설명서"** 입니다.

```typescript
export type GatewayServer = {
  // [1] 기능 정의 (Property: Function)
  // "close 버튼을 누르면 서버가 꺼집니다."
  close: (
      // [2] 선택적 옵션 (Optional Parameter)
      // "옵션은 안 넣어도 됩니다(?). 넣는다면 '이유'와 '재시작 시간'을 적으세요."
      opts?: { reason?: string; restartExpectedMs?: number | null }
  ) 
  // [3] 비동기 약속 (Async Return)
  // "버튼을 누르면 즉시 꺼지지 않고, 완전히 꺼질 때까지 기다려야(Promise) 합니다."
  => Promise<void>;
};
```

1.  **`export type GatewayServer = { ... }`**:
    *   **의미**: "앞으로 `GatewayServer`라고 하면, 무조건 중괄호 `{}` 안에 있는 기능들을 가지고 있어야 한다"는 **계약서(Contract)** 입니다.
    *   **AI 활용법**: AI에게 "서버 만들어줘"라고 하기 전에, **"서버의 리모컨은 무조건 이렇게 생겨야 해"** 라고 이 타입을 먼저 던져주세요. 그러면 AI가 엉뚱한 리모컨을 만들어오지 않습니다.

2.  **`opts?:` (물음표의 마법)**:
    *   **문법**: **Optional Parameter**. 있어도 되고 없어도 되는 값.
    *   **은유**: "선풍기 타이머". 타이머를 안 맞추고(`undefined`) 그냥 꺼도 되고, 1시간 뒤에 꺼지라고 맞춰도 됩니다.
    *   **AI 활용법**: "옵션이 너무 복잡해"라고 느끼면 AI에게 **"모든 필드에 `?`를 붙여서 선택 사항으로 바꿔줘(Make everything optional)"** 라고 지시하세요. 코딩이 훨씬 편해집니다.

3.  **`=> Promise<void>`**:
    *   **문법**: **비동기 반환**.
    *   **의미**: "이 함수는 `return` 값이 없습니다(`void`). 하지만 작업이 끝났다는 신호(`Promise`)는 나중에 보내줍니다."
    *   **현실 비유**: "배달 주문". 짜장면을 시키면(함수 호출), 짜장면이 바로 뽕 하고 나타나지 않습니다. "배달 중(Pending)" 상태였다가 나중에 "도착(Resolved)"합니다.
    *   **AI 활용법**: 요즘 서버 코드는 99%가 비동기입니다. AI에게 **"모든 IO 작업은 무조건 `async/await`로 짜줘"** 라고 미리 못 박으세요. 안 그러면 AI가 옛날 방식(동기식)으로 짜서 서버 전체를 멈추게(Blocking) 할 수도 있습니다.

---

```typescript
// [핵심 함수] 이 함수가 실행되면 서버가 태어납니다.
export async function startGatewayServer(port = 18789, opts: GatewayServerOptions = {}) {
  
  // 1. [준비 단계] 비행 전 점검 (Pre-flight Check)
  // 환경 설정(Config)을 읽어오고, 로그 시스템을 켭니다.
  const config = await loadConfig(CONFIG_PATH_CLAWDBOT); 
  const log = createSubsystemLogger("gateway");
  
  // 2. [실행 단계] 심장 박동 시작 (Heartbeat)
  // 서버가 살아있음을 알리는 심장 박동(Heartbeat) 시스템을 가동합니다.
  const heartbeatHandle = startHeartbeatRunner({ /* ... */ });

  // 3. [연결 단계] 각 부서(장기) 소집
  // 입(HTTP), 귀(WebSocket), 팔다리(Channel) 담당자들을 불러옵니다.
  
  // 3-1. 채널 매니저 (팔다리)
  const channelManager = createChannelManager({ /* ... */ });
  
  // 3-2. HTTP 서버 (입)
  // Hono 앱을 만들고 라우팅을 설정합니다.
  const { app, server } = await createHttpServer({ /* ... */ });
  
  // 3-3. WebSocket 서버 (귀)
  // 실시간 통신을 위한 소켓 서버를 엽니다.
  const wss = await createWebSocketServer({ /* ... */ });

  // 4. [최종 승인] 준비 완료
  // 모든 시스템이 정상적으로 떴다는 로그를 남깁니다.
  log.info(`Gateway running on port ${port}`);

  return { 
    // 나중에 서버를 끄거나 조종할 수 있도록 리모컨(객체)을 반환합니다.
    close: async () => { /* 종료 로직 */ } 
  };
}
```

#### 2-2-2. [배경 지식] 왜 이렇게 모든 걸 한 함수에 넣었나요?
*   **의존성 주입(Dependency Injection)**: 각 장기들은 서로가 필요합니다.
    *   `HTTP 서버`는 `채널 매니저`가 필요합니다. (사용자가 웹에서 "카톡 보내줘"라고 하면 채널 매니저에게 시켜야 하니까요)
    *   `WebSocket 서버`는 `에이전트`가 필요합니다.
*   **중앙 통제**: 만약 각자 따로 켜지면, "HTTP는 켜졌는데 DB가 안 켜지는" 끔찍한 상황이 발생합니다. `server.impl.ts`는 **모든 장기가 완벽하게 준비될 때까지 기다렸다가(await)**, 동시에 출격 명령을 내립니다.

---

### 2-3. 서버의 입, HTTP 서버 (`src/gateway/server-http.ts`) - **[단계 3: 호흡기 연결]**

---

## 3. WhatsApp 채널 연결 (The Sense of Sight/Sound)

봇이 세상을 인식하는 "눈과 귀"입니다. 여기서는 **WhatsApp**을 예로 듭니다.

### 3-1. WhatsApp 어댑터 구현 (`src/channels/whatsapp.ts`)

*   **코드의 역할**: Baileys 라이브러리를 사용하여 실제 WhatsApp 서버와 암호화된 통신을 수행하고, 받은 메시지를 Gateway가 이해할 수 있는 공통 포맷으로 변환(Normalize)합니다.
*   **구현 코드**:

```typescript
// src/channels/whatsapp.ts
import makeWASocket, { useMultiFileAuthState, DisconnectReason } from "@whiskeysockets/baileys";

export async function startWhatsAppChannel(gateway: any) {
  // 1. 인증 상태(세션) 저장소 (파일 기반)
  const { state, saveCreds } = await useMultiFileAuthState("auth_info_baileys");

  // 2. 소켓 연결 생성
  const sock = makeWASocket({
    auth: state,
    printQRInTerminal: true, // QR코드를 터미널에 출력하여 로그인
  });

  // 3. 자격 증명 업데이트 리스너
  sock.ev.on("creds.update", saveCreds);

  // 4. 메시지 수신 리스너
  sock.ev.on("messages.upsert", async ({ messages }) => {
    const msg = messages[0];
    if (!msg.message) return;

    // Normalization: WhatsApp 고유 포맷 -> Gateway 공통 포맷
    const normalizedMsg = {
      id: msg.key.id,
      from: msg.key.remoteJid,
      body: msg.message.conversation || msg.message.extendedTextMessage?.text,
      raw: msg
    };

    // Gateway로 전달
    gateway.emit("message", normalizedMsg);
  });
}
```

*   **테스트 환경 및 방법**:
    *   실제 휴대폰 필요. 터미널에 뜨는 QR 코드를 휴대폰의 WhatsApp 앱(Linked Devices)으로 스캔합니다.
    *   **검증**: `gateway.emit` 부분에 `console.log`를 찍고, 휴대폰에서 봇에게 메시지를 보냈을 때 로그가 찍히는지 확인합니다.
*   **Why?**:
    *   **Abstraction (추상화)**: Gateway는 이것이 WhatsApp인지 Slack인지 몰라야 합니다. 오직 `normalizedMsg`만 처리합니다. 그래야 나중에 Telegram, Discord를 추가할 때 Gateway 코드를 수정할 필요가 없습니다.

---

## 4. AI 에이전트 엔진 (The Brain)

이 앱의 지능을 담당합니다. LLM(OpenAI/Anthropic)에게 "생각할 시간"을 주고 "도구"를 쥐어줍니다.

### 4-1. 에이전트 실행기 (`src/agents/pi-embedded-runner.ts`)

*   **코드의 역할**: 사용자 메시지 + 컨텍스트(이전 대화) + 시스템 프롬프트(너는 누구다)를 합쳐서 LLM에게 보냅니다. LLM이 "파일 읽기 도구를 써줘"라고 하면, 실제로 파일을 읽어서 다시 LLM에게 알려줍니다(**Re-Act 패턴**).
*   **구현 코드**:

```typescript
// src/agents/runner.ts
import { ChatOpenAI } from "@langchain/openai"; // 예시용 라이브러리

export async function runAgent(message: string, context: any[]) {
  // 1. 시스템 프롬프트 정의
  const systemPrompt = `
    You are Moltbot, a helpful AI assistant.
    You have access to the following tools:
    - exec: Run shell commands
    - read_file: Read file contents
  `;

  // 2. LLM 호출
  const llm = new ChatOpenAI({ modelName: "gpt-4o" });
  
  // 3. 메시지 히스토리 조합
  const messages = [
    { role: "system", content: systemPrompt },
    ...context,
    { role: "user", content: message }
  ];

  // 4. 추론 및 실행 루프 (The Loop)
  const response = await llm.call(messages);
  
  // 5. 도구 호출 감지 (간소화됨)
  if (response.content.includes("call: read_file")) {
    // 도구 실행 로직...
    const fileContent = "...file content...";
    // 결과를 다시 LLM에게 피드백 (재귀 호출)
    return runAgent(`Tool Result: ${fileContent}`, [...messages, response]);
  }

  return response.content;
}
```

*   **심층 분석**:
    *   **Context Window Guard**: LLM은 기억 용량(Context Window)에 한계가 있습니다. 따라서 무한정 대화를 저장할 수 없습니다. `pi-embedded-runner.ts`에는 오래된 대화를 요약하거나 삭제하는 **Pruning/Compaction** 로직이 필수적으로 포함됩니다.
    *   **Failover Strategy**: 주 모델(예: Claude 3.5 Sonnet)이 응답하지 않거나 에러를 내면, 자동으로 서브 모델(예: GPT-4o)로 전환하는 **Failover Error Handling**이 구현되어야 서비스가 중단되지 않습니다.

---

## 5. UI 제어 패널 (The Face)

관리자가 봇을 제어하는 화면입니다.

### 5-1. 웹 컴포넌트 구현 (`ui/src/app.ts`)

*   **사용 기술**: **Lit** (Google이 만든 초경량 웹 컴포넌트 라이브러리).
*   **구현 코드**:

```typescript
import { LitElement, html, css } from 'lit';
import { customElement, state } from 'lit/decorators.js';

@customElement('moltbot-app')
export class MoltbotApp extends LitElement {
  @state() messages: string[] = [];

  // 웹소켓 연결
  connectedCallback() {
    super.connectedCallback();
    const ws = new WebSocket('ws://localhost:18789');
    ws.onmessage = (event) => {
      this.messages = [...this.messages, event.data]; // 상태 업데이트 -> 리렌더링
    };
  }

  render() {
    return html`
      <div class="chat-container">
        ${this.messages.map(msg => html`<div class="msg">${msg}</div>`)}
      </div>
    `;
  }
}
```

*   **Why?**: React는 가상 DOM을 쓰지만, Lit은 브라우저 표준인 **Shadow DOM**을 씁니다. Gateway 서버가 정적 파일로 서빙하기에 훨씬 가볍고, 초기 로딩 속도도 빠릅니다.

---

## 6. 결론 및 클론 전략

이 구조를 클론할 때 가장 중요한 것은 **"모듈화(Modularity)"**입니다.

1.  **Gateway를 먼저 만드십시오.** 아무런 로직 없이 HTTP/WS 서버만 띄우세요.
2.  **Mock Channel을 만드십시오.** 실제 WhatsApp을 연결하기 전에, 터미널에서 텍스트를 입력하면 마치 WhatsApp에서 온 것처럼 Gateway에 쏘아주는 가짜 채널을 만드세요. **테스트가 10배 빨라집니다.**
3.  **Dummy Agent를 만드십시오.** LLM 없이 무조건 "알겠습니다"라고 답하는 에이전트를 먼저 연결하세요.
4.  **그 다음 통합하십시오.** Gateway, Channel, Agent가 서로의 존재를 모르게(Decoupling) 인터페이스로만 대화하게 만드는 것이 Moltbot 아키텍처의 핵심입니다.
